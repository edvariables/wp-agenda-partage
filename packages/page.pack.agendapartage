{"0":{"post":{"ID":4745,"post_author":"2","post_date":"2025-12-06 12:14:36","post_date_gmt":"2025-12-06 11:14:36","post_content":"<!-- wp:shortcode -->\n[report \/base\/post\/children :post_status=\"publish\" :post_type=agdpreport :PARENT_POST='0' :LIMIT=99]\n<!-- \/wp:shortcode -->\n\n<!-- wp:paragraph -->\n<p><\/p>\n<!-- \/wp:paragraph -->","post_title":"Rapports","post_excerpt":"","post_status":"publish","comment_status":"closed","ping_status":"closed","post_password":null,"post_name":"rapports","to_ping":"","pinged":"","post_modified":"2025-12-06 12:18:51","post_modified_gmt":"2025-12-06 11:18:51","post_content_filtered":"","post_parent":0,"guid":"http:\/\/agdp.edoc2019\/?page_id=4745","menu_order":0,"post_type":"page","post_mime_type":"","comment_count":"0","filter":"raw"},"metas":{"agdpmailbox":null,"forum_rights":null,"forum_moderate":"0","import_plain_text":"0","comments_purge_delay":null,"forum_show_comments":null,"forum_comment_author_email":"1","forum_comment_title":"1","forum_mark_as_ended":"1","forum_edit_message":"0","forum_edit_message_form":null,"forum_comment_form":"1","forum_reply_link":"1","forum_reply_email":"1","forum_reply_email_default":"0","forum_reply_is_private":"1","forum_reply_is_private_default":"1","forum_comment_css":null,"is_package_root":"1"}},"terms":[{"term":{"term_id":87,"name":"DASHICON","slug":"dashicon","term_group":0,"term_taxonomy_id":87,"taxonomy":"sql_function","description":"Retourne le html d\u2019une ic\u00f4ne (https:\/\/developer.wordpress.org\/resource\/dashicons).","parent":0,"count":0,"filter":"raw"},"metas":{"parameters":"`ICON` TEXT","return_type":"TEXT","body":"RETURN CONCAT('<span class=\"dashicons-before dashicons-', `ICON`, '\"><\/span>');","use_example":"DASHICON('yes')"}},{"term":{"term_id":95,"name":"EDICON","slug":"edicon","term_group":0,"term_taxonomy_id":95,"taxonomy":"sql_function","description":"Retourne le html d\u2019une image pour un \"type\" donn\u00e9","parent":0,"count":0,"filter":"raw"},"metas":{"parameters":"`VAR_TYPE` TEXT","return_type":"TEXT","body":"RETURN CONCAT('<span class=\"edicon ed-', `VAR_TYPE`, '\"><\/span>');","use_example":"SET @_imgs_ESNHZL = CAST(\"[{\\\"key\\\":\\\"0\\\",\\\"value\\\":\\\"Var\\\"},{\\\"key\\\":\\\"1\\\",\\\"value\\\":\\\"App\\\"},{\\\"key\\\":\\\"2\\\",\\\"value\\\":\\\"Type\\\"},{\\\"key\\\":\\\"3\\\",\\\"value\\\":\\\"LibVar\\\"},{\\\"key\\\":\\\"4\\\",\\\"value\\\":\\\"VarName\\\"},{\\\"key\\\":\\\"5\\\",\\\"value\\\":\\\"Name\\\"},{\\\"key\\\":\\\"6\\\",\\\"value\\\":\\\"Add\\\"},{\\\"key\\\":\\\"7\\\",\\\"value\\\":\\\"ReadOnly\\\"},{\\\"key\\\":\\\"8\\\",\\\"value\\\":\\\"Script\\\"},{\\\"key\\\":\\\"9\\\",\\\"value\\\":\\\"DataTable\\\"},{\\\"key\\\":\\\"10\\\",\\\"value\\\":\\\"Visual\\\"},{\\\"key\\\":\\\"11\\\",\\\"value\\\":\\\"Code\\\"},{\\\"key\\\":\\\"12\\\",\\\"value\\\":\\\"EDV\\\"},{\\\"key\\\":\\\"13\\\",\\\"value\\\":\\\"Button\\\"},{\\\"key\\\":\\\"14\\\",\\\"value\\\":\\\"VisualTrue\\\"},{\\\"key\\\":\\\"15\\\",\\\"value\\\":\\\"Web\\\"},{\\\"key\\\":\\\"16\\\",\\\"value\\\":\\\"Print\\\"},{\\\"key\\\":\\\"17\\\",\\\"value\\\":\\\"Component\\\"},{\\\"key\\\":\\\"18\\\",\\\"value\\\":\\\"File\\\"},{\\\"key\\\":\\\"19\\\",\\\"value\\\":\\\"Password\\\"},{\\\"key\\\":\\\"20\\\",\\\"value\\\":\\\"Object\\\"},{\\\"key\\\":\\\"21\\\",\\\"value\\\":\\\"Array\\\"},{\\\"key\\\":\\\"22\\\",\\\"value\\\":\\\"DateTime\\\"},{\\\"key\\\":\\\"23\\\",\\\"value\\\":\\\"Image\\\"},{\\\"key\\\":\\\"24\\\",\\\"value\\\":\\\"DomSys\\\"},{\\\"key\\\":\\\"25\\\",\\\"value\\\":\\\"Dom\\\"},{\\\"key\\\":\\\"26\\\",\\\"value\\\":\\\"Domain\\\"},{\\\"key\\\":\\\"27\\\",\\\"value\\\":\\\"Select\\\"},{\\\"key\\\":\\\"28\\\",\\\"value\\\":\\\"Link\\\"},{\\\"key\\\":\\\"29\\\",\\\"value\\\":\\\"Button\\\"},{\\\"key\\\":\\\"30\\\",\\\"value\\\":\\\"False\\\"},{\\\"key\\\":\\\"31\\\",\\\"value\\\":\\\"Bool\\\"},{\\\"key\\\":\\\"32\\\",\\\"value\\\":\\\"True\\\"},{\\\"key\\\":\\\"33\\\",\\\"value\\\":\\\"Function\\\"},{\\\"key\\\":\\\"34\\\",\\\"value\\\":\\\"Null\\\"},{\\\"key\\\":\\\"35\\\",\\\"value\\\":\\\"Num\\\"},{\\\"key\\\":\\\"36\\\",\\\"value\\\":\\\"String\\\"},{\\\"key\\\":\\\"37\\\",\\\"value\\\":\\\"Text\\\"},{\\\"key\\\":\\\"38\\\",\\\"value\\\":\\\"Color\\\"},{\\\"key\\\":\\\"39\\\",\\\"value\\\":\\\"Client\\\"},{\\\"key\\\":\\\"40\\\",\\\"value\\\":\\\"User\\\"},{\\\"key\\\":\\\"41\\\",\\\"value\\\":\\\"Plus\\\"},{\\\"key\\\":\\\"42\\\",\\\"value\\\":\\\"Minus\\\"}]\" AS JSON);\r\nSELECT CONCAT( EDICON( `value` ), `value`) AS `img`\r\nFROM JSON_TABLE( @_imgs_ESNHZL , \"$[*]\" COLUMNS( `key` TEXT PATH \"$.key\", `value` TEXT PATH \"$.value\" ) ) `imgs`"}},{"term":{"term_id":91,"name":"getPhpSerializedArrayAsJson","slug":"getphpserializedarrayasjson","term_group":0,"term_taxonomy_id":91,"taxonomy":"sql_function","description":"https:\/\/github.com\/Nobiles2\/MySQLToolBox\/blob\/master\/getPhpSerializedArrayValueByKey.sql\r\nCOMMENT 'Function returns last value from serialized array by specific string key.'","parent":0,"count":0,"filter":"raw"},"metas":{"parameters":"_input_string TEXT","return_type":"JSON","use_example":"JSON_PRETTY( getPhpSerializedArrayAsJson('a:30:{s:25:\"blog_presentation_page_id\";s:1:\"2\";s:28:\"newsletter_subscribe_page_id\";s:4:\"2043\";s:28:\"newsletter_subscribe_form_id\";s:4:\"2074\";s:27:\"agdpforum_subscribe_form_id\";s:4:\"4640\";s:15:\"contact_page_id\";s:2:\"59\";s:15:\"contact_form_id\";s:3:\"100\";s:16:\"admin_nl_post_id\";s:4:\"3022\";s:14:\"agenda_page_id\";s:2:\"10\";s:21:\"new_agdpevent_page_id\";s:3:\"156\";s:22:\"agdpevent_edit_form_id\";s:2:\"31\";s:33:\"agdpevent_message_contact_form_id\";s:3:\"149\";s:29:\"admin_message_contact_form_id\";s:3:\"149\";s:17:\"events_nl_post_id\";s:4:\"2062\";s:31:\"agdpevents_nl_diffusion_term_id\";s:2:\"-1\";s:25:\"agdpevent_need_validation\";s:2:\"on\";s:19:\"covoiturage_managed\";s:2:\"on\";s:20:\"covoiturages_page_id\";s:4:\"3130\";s:23:\"new_covoiturage_page_id\";s:4:\"3133\";s:24:\"covoiturage_edit_form_id\";s:4:\"3129\";s:23:\"covoiturages_nl_post_id\";s:4:\"3289\";s:33:\"covoiturages_nl_diffusion_term_id\";s:2:\"43\";s:19:\"connect_menu_enable\";s:2:\"on\";s:14:\"maillog_enable\";s:2:\"on\";s:15:\"debuglog_enable\";s:2:\"on\";s:32:\"agdpevent_import_ics-post_status\";s:7:\"publish\";s:27:\"covoiturage_need_validation\";b:0;s:23:\"allow_html_in_agdpevent\";b:0;s:25:\"allow_html_in_covoiturage\";b:0;s:16:\"disable_sitemaps\";s:2:\"on\";s:28:\"agdpevent_import_ics-confirm\";i:487785537;}') )","body":"\/*\r\n\t\tFunction returns last value from serialized array by specific string key.\r\n\t\t\r\n        see https:\/\/en.wikipedia.org\/wiki\/PHP_serialization_format\r\n        \r\n\t\t@author Emmanuel Durand inspired from Adam Wn\u0119k (http:\/\/kredyty-chwilowki.pl\/)\r\n\t\t@licence MIT\r\n\t\t@version 1.2\r\n\t*\/\r\n\t-- required variables\r\n    DECLARE __output_part,__extra_byte_counter,__extra_byte_number,__array_part_temp TEXT;\r\n\tDECLARE __char_ord,__start,__char_counter,__non_multibyte_length,__array_close_bracket_counter,__array_open_bracket_counter, __close_bracket_position INT SIGNED;\r\n\t\t\t\r\n\tDECLARE __json, __json_item JSON;\r\n    DECLARE __open_bracket, __close_bracket, __begin_pos, __key_pos, __key_length, __value_length, __after_key, __after_value INT SIGNED;\r\n    DECLARE __key, __length, __key_type, __value_type, __value_class, __value TEXT;\r\n    DECLARE __value_bool BOOL;\r\n    DECLARE __value_int LONG;\r\n    DECLARE __value_float DOUBLE;\r\n    DECLARE __error, __debug TEXT DEFAULT '';\r\n    DECLARE __items INT UNSIGNED DEFAULT 0;\r\n    DECLARE __items_max INT UNSIGNED DEFAULT 999;\r\n    \r\n    SET __json = JSON_OBJECT();\r\n    \r\n    SET __open_bracket = LOCATE( '{', _input_string, 1 );\r\n    SET __close_bracket = LOCATE( '}', _input_string, __open_bracket );\r\n    SET __begin_pos = __open_bracket + 1;\r\n    \r\n    WHILE ( __error = ''\r\n           AND __begin_pos > 0\r\n           AND __begin_pos < __close_bracket\r\n           AND __items < __items_max ) DO\r\n        \r\n        -- ---\r\n        -- Reset\r\n       SET __json_item = null;\r\n        \r\n        -- ---\r\n        -- Key\r\n        -- {s: or {i:\r\n        SET __after_key = LOCATE( ':', _input_string, __begin_pos + 1);\r\n        SET __key_type = SUBSTRING( _input_string, __begin_pos, __after_key - __begin_pos );\r\n        CASE __key_type\r\n        WHEN 'i' THEN\r\n        \tBEGIN\r\n                -- {i:0;\r\n                SET __begin_pos = __after_key + 1;\r\n                SET __after_key = LOCATE( ';', _input_string, __begin_pos);\r\n                SET __key = SUBSTRING( _input_string, __begin_pos, __after_key - __begin_pos );\r\n                SET __begin_pos = __after_key + 1;\r\n            END;\r\n        WHEN 's' THEN\r\n        \tBEGIN\r\n                -- {s:99:\r\n                SET __begin_pos = __after_key + 1;\r\n                SET __after_key = LOCATE( ':', _input_string, __begin_pos);\r\n                SET __key_length = SUBSTRING( _input_string, __begin_pos, __after_key - __begin_pos );\r\n                -- {s:99:\"key\"\r\n                SET __key = SUBSTRING( _input_string, __after_key + 1 + 1, __key_length );\r\n                SET __after_key = __after_key + __key_length + 2;\r\n                -- {s:99:\"key\";\r\n                SET __after_key = LOCATE( ';', _input_string, __after_key + 1);\r\n                SET __begin_pos = __after_key + 1;\r\n            END;\r\n        ELSE\r\n\t\t\tSET __json_item = JSON_OBJECT( '#unserialize ERROR', CONCAT(__key_type, '\" n\\'est pas un type analys\u00e9 pour le champ cl\u00e9. Proche de ', SUBSTRING( _input_string, __begin_pos, 20 ) ) );\r\n            \r\n\t\t\tRETURN JSON_MERGE_PRESERVE(__json, __json_item);\r\n            \r\n            RETURN JSON_OBJECT( '#ERROR', CONCAT(__key_type, '\" n\\'est pas un type analys\u00e9 pour le champ cl\u00e9. Proche de ', SUBSTRING( _input_string, __begin_pos, 20 ) ) );\r\n        END CASE;\r\n        \r\n        -- ---\r\n        -- Value\r\n        -- {s:99:\"key\";s:  {s:99:\"key\";N;\r\n        SET __after_value = LOCATE( ':', _input_string, __begin_pos);\r\n        SET __value_type = SUBSTRING( _input_string, __begin_pos, __after_value - __begin_pos );\r\n        IF SUBSTRING(__value_type, 1, 1) = 'N' THEN\r\n            SET __after_value = __begin_pos + 1;\r\n            SET __value_type = 'N';\r\n        END IF;\r\n        -- {s:99:\"key\";s:99:\r\n        SET __begin_pos = __after_value + 1;\r\n        -- {s:99:\"key\";s:99:\"value\";\r\n        CASE -- [s,a,b,O,i,d,N]\r\n        \/* N : Null *\/\r\n        WHEN __value_type = 'N' THEN\r\n        \tBEGIN\r\n                SET __value = NULL;\r\n\t\t\t\tSET __json_item = JSON_OBJECT( __key, __value );\r\n            END;\r\n        \/* b, i, d : Bool, Int, Float *\/\r\n        WHEN __value_type = 'b' \r\n          OR __value_type = 'i' \r\n          OR __value_type = 'd' THEN\r\n        \tBEGIN\r\n                -- {s:99:\"key\";b:1;\r\n        \t\tSET __after_value = LOCATE( ';', _input_string, __begin_pos);\r\n                SET __value = SUBSTRING( _input_string, __begin_pos, __after_value - __begin_pos );\r\n                SET __value_length = LENGTH( __value );\r\n        \r\n                CASE __value_type\r\n                WHEN 'b' THEN BEGIN SET __value_bool = __value; SET __json_item = JSON_OBJECT( __key, __value_bool ); END;\r\n                WHEN 'i' THEN BEGIN SET __value_int = __value; SET __json_item = JSON_OBJECT( __key, __value_int ); END;\r\n                WHEN 'f' THEN BEGIN SET __value_float = __value; SET __json_item = JSON_OBJECT( __key, __value_float ); END;\r\n                END CASE;\r\n\t\t\t\tSET __begin_pos = __after_value + 1;\r\n            END;\r\n        \/* s : String *\/\r\n        WHEN __value_type = 's' THEN\r\n        \tBEGIN\r\n        \t\tSET __after_value = LOCATE( ':', _input_string, __begin_pos);\r\n                SET __value_length = SUBSTRING( _input_string, __begin_pos, __after_value - __begin_pos );\r\n                SET __begin_pos = __after_value + 2; -- \"\r\n                -- SET __value = SUBSTRING( _input_string, __begin_pos, __value_length );\r\n                \r\n                \/* Analyse la suite (les caract\u00e8res sp\u00e9ciaux prennent plus de place qu'indiqu\u00e9e) *\/\r\n\t\t\t\tSET __output_part := SUBSTRING(_input_string, __begin_pos, __value_length); -- toute la suite en plus long que n\u00e9cessaire\r\n                SET __char_counter := 1;\r\n\t\t\t\r\n                -- real length to cut\r\n                SET __non_multibyte_length := 0;\r\n\r\n                SET __start := 0;\r\n                -- check every char until [__value_length]\r\n                WHILE __start < __value_length DO\r\n\r\n                    SET __char_ord := ORD(SUBSTR(__output_part,__char_counter,1));\r\n\r\n                    SET __extra_byte_number := 0;\r\n                    SET __extra_byte_counter := FLOOR(__char_ord \/ 256);\r\n\r\n                    -- we detect multibytechars and count them as one to substring correctly\r\n                    -- when we now how many chars make multibytechar we can use it to count what is non multibyte length of our value\r\n                    WHILE __extra_byte_counter > 0 DO\r\n                        SET __extra_byte_counter := FLOOR(__extra_byte_counter \/ 256);\r\n                        SET __extra_byte_number := __extra_byte_number+1;\r\n                    END WHILE;\r\n\r\n                    -- to every char i add extra multibyte number (for non multibyte char its 0)\r\n                    SET __start := __start + 1 + __extra_byte_number;\t\t\t\r\n                    SET __char_counter := __char_counter + 1;\r\n                    SET __non_multibyte_length := __non_multibyte_length +1;\r\n\r\n                END WHILE;\r\n                SET __value :=  SUBSTRING(__output_part,1,__non_multibyte_length);\r\n                SET __value_length := __non_multibyte_length;\r\n                \r\n                \/*  *\/\r\n        \t\tSET __after_value = LOCATE( ';', _input_string, __begin_pos + __value_length + 1);\r\n\t\t\t\tSET __begin_pos = __after_value + 1;\r\n                \r\n                IF( LOCATE( '}', __value) > 0 ) THEN\r\n                \tSET __close_bracket = LOCATE( '}', _input_string, __begin_pos);\r\n                END IF;\r\n        \r\n\t\t\t\tSET __json_item = JSON_OBJECT( __key, __value );\r\n            END;\r\n        \/* a : Array *\/\r\n        WHEN __value_type = 'a' THEN \r\n        \tBEGIN\r\n        \t\tSET __after_value = LOCATE( '{', _input_string, __begin_pos);\r\n                SET __value_length = SUBSTRING( _input_string, __begin_pos, __after_value - __begin_pos ); -- array size\r\n                SET __begin_pos = __after_value; -- {\r\n                \r\n        \t\t-- we get proper array by counting open and close brackets\r\n                SET __array_open_bracket_counter := 1;\r\n                SET __array_close_bracket_counter := 0;\r\n                -- without first open { so counter is 1\r\n                SET __array_part_temp := SUBSTRING(_input_string, __begin_pos + 1);\r\n\t\t\t\tSET __after_value = __begin_pos + 1;\r\n                \r\n                -- we start from first { and counting open and closet brackets until we find last closing one\r\n                WHILE (__array_open_bracket_counter > 0 AND LENGTH(__array_part_temp) > 0) DO\r\n                    -- next { exists and its before closest }\r\n                    IF LOCATE('{',__array_part_temp) > 0 AND (LOCATE('{',__array_part_temp) < LOCATE('}',__array_part_temp)) THEN\r\n                        -- cut from found { + 1, to the end\r\n                        SET __array_open_bracket_counter := __array_open_bracket_counter + 1;\r\n                        SET __after_value = __after_value + LOCATE('{',__array_part_temp);\r\n                        SET __array_part_temp := SUBSTRING(__array_part_temp FROM LOCATE('{',__array_part_temp) + 1);\t\t\t\t\t\r\n                    ELSE\r\n                        -- cut from found } + 1, to the end\r\n                        SET __array_open_bracket_counter := __array_open_bracket_counter - 1;\r\n                        SET __array_close_bracket_counter := __array_close_bracket_counter + 1;\r\n                        \r\n                        SET __close_bracket_position = LOCATE('}',__array_part_temp);\r\n                        SET __array_part_temp := SUBSTRING(__array_part_temp FROM LOCATE('}',__array_part_temp) + 1);\r\n                        SET __after_value = __after_value + __close_bracket_position;\r\n                    END IF;\r\n                END WHILE;\r\n                -- final array is from beginning to [__array_close_bracket_counter] count of closing }\r\n                SET __value := CONCAT(SUBSTRING_INDEX( SUBSTRING(_input_string, __begin_pos) ,'}',__array_close_bracket_counter),'}');\r\n                SET __value := CONCAT(__value_type, ':', __value_length, ':', __value);\r\n                \r\n                SET __close_bracket = LOCATE( '}', _input_string, __after_value );\r\n                SET __begin_pos = __after_value;\r\n        \r\n\t\t\t\tSET __json_item = JSON_OBJECT( __key, __value );\r\n            END;\r\n        \/* O : Object *\/\r\n        WHEN __value_type = 'O' THEN \r\n        \tBEGIN\r\n            \t-- O:8:\"stdClass\":2:{s:2:\"o1\";s:3:\"O 1\";s:2:\"o2\";s:3:\"O 2\";}\r\n        \t\tSET __after_value = LOCATE( ':', _input_string, __begin_pos);\r\n                SET __value_length = SUBSTRING( _input_string, __begin_pos, __after_value - __begin_pos );\r\n                SET __begin_pos = __after_value + 1;\r\n                SET __after_value = LOCATE( ':', _input_string, __begin_pos);\r\n                SET __value_class = SUBSTRING( _input_string, __begin_pos + 1, __after_value - __begin_pos - 2 );\r\n                SET __begin_pos = __after_value + 1;\r\n                SET __after_value = LOCATE( '{', _input_string, __begin_pos);\r\n                SET __value_length = SUBSTRING( _input_string, __begin_pos, __after_value - __begin_pos );\r\n                SET __begin_pos = __after_value; -- {\r\n                \r\n        \t\t-- we get proper array by counting open and close brackets\r\n                SET __array_open_bracket_counter := 1;\r\n                SET __array_close_bracket_counter := 0;\r\n                -- without first open { so counter is 1\r\n                SET __array_part_temp := SUBSTRING(_input_string, __begin_pos + 1);\r\n\t\t\t\tSET __after_value = __begin_pos + 1;\r\n                \r\n                -- we start from first { and counting open and closet brackets until we find last closing one\r\n                WHILE (__array_open_bracket_counter > 0 AND LENGTH(__array_part_temp) > 0) DO\r\n                    -- next { exists and its before closest }\r\n                    IF LOCATE('{',__array_part_temp) > 0 AND (LOCATE('{',__array_part_temp) < LOCATE('}',__array_part_temp)) THEN\r\n                        -- cut from found { + 1, to the end\r\n                        SET __array_open_bracket_counter := __array_open_bracket_counter + 1;\r\n                        SET __after_value = __after_value + LOCATE('{',__array_part_temp);\r\n                        SET __array_part_temp := SUBSTRING(__array_part_temp FROM LOCATE('{',__array_part_temp) + 1);\t\t\t\t\t\r\n                    ELSE\r\n                        -- cut from found } + 1, to the end\r\n                        SET __array_open_bracket_counter := __array_open_bracket_counter - 1;\r\n                        SET __array_close_bracket_counter := __array_close_bracket_counter + 1;\r\n                        \r\n                        SET __close_bracket_position = LOCATE('}',__array_part_temp);\r\n                        SET __array_part_temp := SUBSTRING(__array_part_temp FROM LOCATE('}',__array_part_temp) + 1);\r\n                        SET __after_value = __after_value + __close_bracket_position;\r\n                    END IF;\r\n                END WHILE;\r\n                -- final array is from beginning to [__array_close_bracket_counter] count of closing }\r\n                SET __value := CONCAT(SUBSTRING_INDEX( SUBSTRING(_input_string, __begin_pos) ,'}',__array_close_bracket_counter),'}');\r\n                SET __value := CONCAT(__value_type, ':', LENGTH(__value_class), ':\"', __value_class, '\":', __value_length, ':', __value);\r\n                \r\n                SET __close_bracket = LOCATE( '}', _input_string, __after_value );\r\n                SET __begin_pos = __after_value;\r\n        \r\n\t\t\t\tSET __json_item = JSON_OBJECT( __key, __value );\r\n            END;\r\n        ELSE\r\n            -- SET __error = CONCAT('Erreur : \"', __value_type, '\" n\\'est pas un type analys\u00e9.');\r\n\t\t\t\tSET __json_item = JSON_OBJECT( '#unserialize ERROR', CONCAT('Erreur : \"', __value_type, '\" n\\'est pas un type analys\u00e9.') );\r\n        END CASE;\r\n        \r\n\t\tIF __error != '' THEN\r\n        \tRETURN CONCAT(__error\r\n                          , '\\nDEBUG : ', JSON_PRETTY( JSON_OBJECT('__value_type', __value_type, '__value_length', __value_length ) )\r\n                          , '\\nJSON : ', JSON_PRETTY( __json )\r\n        \t);\r\n        END IF;\r\n        \r\n        IF( NOT __json_item IS NULL ) THEN\r\n\t\t\tSET __json = JSON_MERGE_PRESERVE(__json, __json_item);\r\n\t\tEND IF;\r\n        \r\n        IF SUBSTRING( _input_string, __begin_pos, 1 ) = '}' THEN\r\n        \tSET __begin_pos = -1;\r\n        -- ELSE\r\n        \t-- SET __error = SUBSTRING( _input_string, __begin_pos );\r\n        END IF;\r\n        \r\n        SET __items = __items + 1;\r\n\tEND WHILE;\r\n\r\n\tIF __items >= __items_max THEN\r\n        SET __error = 'INFINITE LOOP';\r\n    END IF;\r\n    \r\n    IF __debug != '' THEN\r\n        RETURN JSON_OBJECT( '__debug', __debug );\r\n    END IF;\r\n\tIF __error != '' THEN\r\n        RETURN JSON_OBJECT( 'ERROR', CONCAT(__error\r\n                          , '\\nJSON ; ', JSON_PRETTY( __json )\r\n                      \t  , '\\n_input_string ; ', _input_string\r\n        ));\r\n    END IF;\r\n    \r\n    RETURN __json;"}},{"term":{"term_id":93,"name":"getPhpSerializedArrayAsKeyValueTable","slug":"getphpserializedarrayaskeyvaluetable","term_group":0,"term_taxonomy_id":93,"taxonomy":"sql_function","description":"","parent":0,"count":0,"filter":"raw"},"metas":{"body":"\/*\r\n\tFunction returns last value from serialized array by specific string key.\r\n\t\t\r\n\tsee https:\/\/en.wikipedia.org\/wiki\/PHP_serialization_format\r\n        \r\n\t@author Emmanuel Durand inspired from Adam Wn\u0119k (http:\/\/kredyty-chwilowki.pl\/)\r\n\t@licence MIT\r\n\t@version 1.2\r\n*\/\r\n\t-- required variables\r\n\tDECLARE __json, __json_keys, __json_KV, __json_item JSON;\r\n    DECLARE __index, __length INT UNSIGNED DEFAULT 0;\r\n    DECLARE __key, __value TEXT;\r\n    SET __json = getPhpSerializedArrayAsJson(`_input_string`);\r\n    SET __json_keys = JSON_KEYS(__json);\r\n    SET __json_KV = JSON_ARRAY();\r\n    \r\n    SET __length = JSON_LENGTH(__json);\r\n    WHILE __index < __length DO\r\n        SET __key = JSON_EXTRACT(__json_keys, CONCAT(\"$[\", __index, \"]\"));\r\n        IF NOT __key IS NULL AND  __key != '' THEN\r\n            SET __value = JSON_UNQUOTE( JSON_EXTRACT(__json, CONCAT(\"$[0].\", __key)));\r\n            SET __json_item = JSON_OBJECT('key', JSON_UNQUOTE(__key), 'value', __value);\r\n\r\n            SET __json_KV = JSON_MERGE_PRESERVE(__json_KV, __json_item);\r\n\t\tEND IF;\r\n        SET __index = __index + 1;\r\n   END WHILE;\r\n    \r\n    RETURN __json_KV;","parameters":"`_input_string` TEXT","return_type":"JSON","use_example":"SET @JSO = getPhpSerializedArrayAsKeyValueTable( 'a:30:{s:25:\"blog_presentation_page_id\";s:1:\"2\";s:28:\"newsletter_subscribe_page_id\";s:4:\"2043\";s:28:\"newsletter_subscribe_form_id\";s:4:\"2074\";s:27:\"agdpforum_subscribe_form_id\";s:4:\"4640\";s:15:\"contact_page_id\";s:2:\"59\";s:15:\"contact_form_id\";s:3:\"100\";s:16:\"admin_nl_post_id\";s:4:\"3022\";s:14:\"agenda_page_id\";s:2:\"10\";s:21:\"new_agdpevent_page_id\";s:3:\"156\";s:22:\"agdpevent_edit_form_id\";s:2:\"31\";s:33:\"agdpevent_message_contact_form_id\";s:3:\"149\";s:29:\"admin_message_contact_form_id\";s:3:\"149\";s:17:\"events_nl_post_id\";s:4:\"2062\";s:31:\"agdpevents_nl_diffusion_term_id\";s:2:\"-1\";s:25:\"agdpevent_need_validation\";s:2:\"on\";s:19:\"covoiturage_managed\";s:2:\"on\";s:20:\"covoiturages_page_id\";s:4:\"3130\";s:23:\"new_covoiturage_page_id\";s:4:\"3133\";s:24:\"covoiturage_edit_form_id\";s:4:\"3129\";s:23:\"covoiturages_nl_post_id\";s:4:\"3289\";s:33:\"covoiturages_nl_diffusion_term_id\";s:2:\"43\";s:19:\"connect_menu_enable\";s:2:\"on\";s:14:\"maillog_enable\";s:2:\"on\";s:15:\"debuglog_enable\";s:2:\"on\";s:32:\"agdpevent_import_ics-post_status\";s:7:\"publish\";s:27:\"covoiturage_need_validation\";b:0;s:23:\"allow_html_in_agdpevent\";b:0;s:25:\"allow_html_in_covoiturage\";b:0;s:16:\"disable_sitemaps\";s:2:\"on\";s:28:\"agdpevent_import_ics-confirm\";i:487785537;}');\r\nSELECT * FROM JSON_TABLE( @JSO, \"$[*]\" COLUMNS( `key` TEXT PATH \"$.key\", `value` TEXT PATH \"$.value\" ) ) `JSON`"}},{"term":{"term_id":90,"name":"getPhpSerializedArrayValueByKey","slug":"getphpserializedarrayvaluebykey","term_group":0,"term_taxonomy_id":90,"taxonomy":"sql_function","description":"https:\/\/github.com\/Nobiles2\/MySQLToolBox\/blob\/master\/getPhpSerializedArrayValueByKey.sql\r\nCOMMENT 'Function returns last value from serialized array by specific string key.'","parent":0,"count":0,"filter":"raw"},"metas":{"parameters":"_input_string TEXT, _key TEXT","return_type":"TEXT CHARSET utf8","body":"\/*\r\n\t\tFunction returns last value from serialized array by specific string key.\r\n\t\t\r\n\t\t@author Adam Wn\u0119k (http:\/\/kredyty-chwilowki.pl\/)\r\n\t\t@licence MIT\r\n\t\t@version 1.2\r\n\t*\/\r\n\t-- required variables\r\n\tDECLARE __output_part,__output,__extra_byte_counter,__extra_byte_number,__value_type,__array_part_temp TEXT;\r\n\tDECLARE __value_length,__char_ord,__start,__char_counter,__non_multibyte_length,__array_close_bracket_counter,__array_open_bracket_counter INT SIGNED;\r\n\tSET __output := NULL;\r\n\t\r\n\t-- check if key exists in input\r\n\tIF LOCATE(CONCAT('s:',LENGTH(_key),':\"',_key,'\";'), _input_string) != 0 THEN\r\n\t\r\n\t\t-- cut from right to key\t\t\r\n\t\tSET __output_part := SUBSTRING_INDEX(_input_string,CONCAT('s:',LENGTH(_key),':\"',_key,'\";'),-1);\r\n\t\t\r\n\t\t-- get type of value [s,a,b,O,i,d]\r\n\t\tSET __value_type := SUBSTRING(SUBSTRING(__output_part, 1, CHAR_LENGTH(SUBSTRING_INDEX(__output_part,';',1))), 1, 1);\r\n\t\t\r\n\t\t-- custom cut depends of value type\r\n\t\tCASE \t\r\n\t\tWHEN __value_type = 'a' THEN\r\n\t\t\t-- we get proper array by counting open and close brackets\r\n\t\t\tSET __array_open_bracket_counter := 1;\r\n\t\t\tSET __array_close_bracket_counter := 0;\r\n\t\t\t-- without first open { so counter is 1\r\n\t\t\tSET __array_part_temp := SUBSTRING(__output_part FROM LOCATE('{',__output_part)+1);\r\n\t\t\t\r\n\t\t\t-- we start from first { and counting open and closet brackets until we find last closing one\r\n\t\t\tWHILE (__array_open_bracket_counter > 0 OR LENGTH(__array_part_temp) = 0) DO\r\n\t\t\t\t-- next { exists and its before closest }\r\n\t\t\t\tIF LOCATE('{',__array_part_temp) > 0 AND (LOCATE('{',__array_part_temp) < LOCATE('}',__array_part_temp)) THEN\r\n\t\t\t\t\t-- cut from found { + 1, to the end\r\n\t\t\t\t\tSET __array_open_bracket_counter := __array_open_bracket_counter + 1;\r\n\t\t\t\t\tSET __array_part_temp := SUBSTRING(__array_part_temp FROM LOCATE('{',__array_part_temp) + 1);\t\t\t\t\t\r\n\t\t\t\tELSE\r\n\t\t\t\t\t-- cut from found } + 1, to the end\r\n\t\t\t\t\tSET __array_open_bracket_counter := __array_open_bracket_counter - 1;\r\n\t\t\t\t\tSET __array_close_bracket_counter := __array_close_bracket_counter + 1;\r\n\t\t\t\t\tSET __array_part_temp := SUBSTRING(__array_part_temp FROM LOCATE('}',__array_part_temp) + 1);\t\t\t\t\t\r\n\t\t\t\tEND IF;\r\n\t\t\tEND WHILE;\r\n\t\t\t-- final array is from beginning to [__array_close_bracket_counter] count of closing }\r\n\t\t\tSET __output := CONCAT(SUBSTRING_INDEX(__output_part,'}',__array_close_bracket_counter),'}');\r\n\t\t\t\r\n\t\tWHEN __value_type = 'd' OR __value_type = 'i' OR __value_type = 'b' THEN\r\n\t\t\t\r\n\t\t\t-- from left to first appearance of }, from right to first :\r\n\t\t\tSET __output := SUBSTRING_INDEX(SUBSTRING_INDEX(__output_part,';',1),':',-1);\r\n\t\t\t\r\n\t\tWHEN __value_type = 'O' THEN\t\t\t\r\n\t\t\t\r\n\t\t\t-- from left to first appearance of ;} but without it so we add it back\r\n\t\t\tSET __output := CONCAT(SUBSTRING_INDEX(__output_part,';}',1),';}');\r\n\t\t\t\r\n\t\tWHEN __value_type = 'N' THEN \r\n            -- when we have null return empty string\r\n            SET __output := NULL;\t\t\r\n\t\tELSE\r\n\t\t\t\r\n\t\t\t-- get serialized length\r\n\t\t\tSET __value_length := SUBSTRING_INDEX(SUBSTRING_INDEX(SUBSTRING_INDEX(__output_part, ':', 2),':',-1),';',1);\r\n\t\t\t\r\n\t\t\t-- s:10:\" -> 7 because we start after \"\r\n\t\t\t-- we cut from the begin of our value to the end\r\n\t\t\t-- begin of our string is after: s[1] + :[1] + n[length of number] + :[1] + \"[1] + [1](begin after \") = 5+n\t\t\t\r\n\t\t\tSET __output_part := SUBSTRING(__output_part, 5+LENGTH(__value_length));\r\n\t\t\t\r\n\t\t\tSET __char_counter := 1;\r\n\t\t\t\r\n\t\t\t-- real length to cut\r\n\t\t\tSET __non_multibyte_length := 0;\r\n\t\t\t\r\n\t\t\tSET __start := 0;\r\n\t\t\t-- check every char until [__value_length]\r\n\t\t\tWHILE __start < __value_length DO\r\n\t\t\t\r\n\t\t\t\tSET __char_ord := ORD(SUBSTR(__output_part,__char_counter,1));\r\n\t\t\t\t\r\n\t\t\t\tSET __extra_byte_number := 0;\r\n\t\t\t\tSET __extra_byte_counter := FLOOR(__char_ord \/ 256);\r\n\t\t\t\t\r\n\t\t\t\t-- we detect multibytechars and count them as one to substring correctly\r\n\t\t\t\t-- when we now how many chars make multibytechar we can use it to count what is non multibyte length of our value\r\n\t\t\t\tWHILE __extra_byte_counter > 0 DO\r\n\t\t\t\t\tSET __extra_byte_counter := FLOOR(__extra_byte_counter \/ 256);\r\n\t\t\t\t\tSET __extra_byte_number := __extra_byte_number+1;\r\n\t\t\t\tEND WHILE;\r\n\t\t\t\t\r\n\t\t\t\t-- to every char i add extra multibyte number (for non multibyte char its 0)\r\n\t\t\t\tSET __start := __start + 1 + __extra_byte_number;\t\t\t\r\n\t\t\t\tSET __char_counter := __char_counter + 1;\r\n\t\t\t\tSET __non_multibyte_length := __non_multibyte_length +1;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\tEND WHILE;\r\n\t\t\t\r\n\t\t\tSET __output :=  SUBSTRING(__output_part,1,__non_multibyte_length);\r\n\t\t\t\t\t\r\n\t\tEND CASE;\t\t\r\n\tEND IF;\r\n\tRETURN __output;\r\n","use_example":"SELECT :key AS 'key', getPhpSerializedArrayValueByKey( `option_value`, :key ) AS `key_value`, `option_value`\r\nFROM @.options `option`\r\nWHERE `option`.`option_name` = :name\r\nAND ( :key = '' OR `option`.`option_value` REGEXP CONCAT(':\\\"', :key , '\\\";') )\r\nLIMIT :LIMIT"}},{"term":{"term_id":94,"name":"INPUT","slug":"input","term_group":0,"term_taxonomy_id":94,"taxonomy":"sql_function","description":"","parent":0,"count":1,"filter":"raw"},"metas":{"parameters":"`_name` TEXT, `_value` TEXT, `_type` TEXT, `_attrs` JSON","return_type":"TEXT CHARSET utf8mb4","body":"DECLARE __html, __attrs TEXT DEFAULT '';\r\n\r\nSET __html = CONCAT('<input'\r\n, ' type=\"', _type, '\"'\r\n, ' name=\"', _name, '\"'\r\n, ' value=\"', REPLACE(_value, '\"', '&quot;'), '\"'\r\n, '>'\r\n);\r\n  RETURN __html;"}},{"term":{"term_id":89,"name":"LABEL","slug":"label","term_group":0,"term_taxonomy_id":89,"taxonomy":"sql_function","description":"Retourne le Html d'un label avec une ic\u00f4ne","parent":0,"count":0,"filter":"raw"},"metas":{"parameters":"`LABEL` TEXT, `ICON` TEXT","return_type":"TEXT","body":"RETURN CONCAT('<label>'\r\n, IF(NOT `ICON` IS NULL AND `ICON` != ''\r\n   , CONCAT('<span class=\"dashicons-before dashicons-', `ICON`, '\"><\/span>'), '')\r\n  , `LABEL`\r\n, '<\/label>')","use_example":"LABEL('Hello', 'site')"}},{"term":{"term_id":92,"name":"Largeur adapt\u00e9e de 1\u00e8re colonne","slug":"largeur-adaptee-de-1ere-colonne","term_group":0,"term_taxonomy_id":92,"taxonomy":"report_style","description":"table td:first-of-type, table th:first-of-type {\r\nwidth: 0px;\r\n}","parent":0,"count":3,"filter":"raw"},"metas":[]},{"term":{"term_id":84,"name":"Lignes altern\u00e9es","slug":"lignes-alternees","term_group":0,"term_taxonomy_id":84,"taxonomy":"report_style","description":"table &gt; * &gt; tr:nth-child(even) &gt; * {\r\n    background-color: rgb(211, 209, 186);\r\n}\r\nbody.colors-dark table &gt; * &gt; tr:nth-child(even) &gt; * {\r\n    background-color: rgb(55, 54, 48);\r\n}","parent":0,"count":5,"filter":"raw"},"metas":[]},{"term":{"term_id":73,"name":"Lignes horizontales","slug":"lignes-horizontales","term_group":0,"term_taxonomy_id":73,"taxonomy":"report_style","description":"table td, table th {\r\n  border: none;\r\n  border-bottom: solid 2px black;\r\n}","parent":0,"count":3,"filter":"raw"},"metas":[]},{"term":{"term_id":74,"name":"Premi\u00e8re cellule seule","slug":"premiere-cellule-seule","term_group":0,"term_taxonomy_id":74,"taxonomy":"report_style","description":"table &gt; thead &gt; tr, table &gt; tbody &gt; tr, table &gt; tfoot {\r\n  display: none;\r\n}\r\ntable.report_table_designer &gt; thead &gt; tr, table.report_table_designer &gt; tbody &gt; tr {\r\n  display: table-row;\r\n}\r\ntable.report_table_designer &gt; thead &gt; tr {\r\n  opacity: 60%;\r\n}\r\ntable &gt; tbody &gt; tr.report_table_designer {\r\n  display: table-row;\r\n}\r\ntable &gt; tbody &gt; tr:not(.report_table_designer) {\r\n  display: table-row;\r\n}\r\ntable &gt; tbody &gt; tr:not(.report_table_designer) ~tr {\r\n  display: none;\r\n}\r\n","parent":0,"count":0,"filter":"raw"},"metas":[]},{"term":{"term_id":88,"name":"Sans en-t\u00eates de colonnes","slug":"sans-en-tetes-de-colonnes","term_group":0,"term_taxonomy_id":88,"taxonomy":"report_style","description":"table &gt; thead &gt; tr {\r\n  display: none;\r\n}\r\ntable.report_table_designer &gt; thead &gt; tr {\r\n  display: table-row;\r\n  opacity: 60%;\r\n}","parent":0,"count":2,"filter":"raw"},"metas":[]},{"term":{"term_id":96,"name":"Table sans bordure","slug":"table-sans-bordure","term_group":0,"term_taxonomy_id":96,"taxonomy":"report_style","description":"table, table tr, table th, table td {\r\n  border: none !important;\r\n}\r\ntable td {\r\n  vertical-align: top;\r\n}","parent":0,"count":2,"filter":"raw"},"metas":[]},{"term":{"term_id":86,"name":"TOGGLER","slug":"toggler","term_group":0,"term_taxonomy_id":86,"taxonomy":"sql_function","description":"Retourne le html d'un toggler vers un sous-rapport.","parent":0,"count":0,"filter":"raw"},"metas":{"parameters":"`REPORT_ID` TEXT, `TITLE` TEXT, `VARS_JSON` JSON","return_type":"TEXT","body":"IF( `TITLE` IS NULL || `TITLE` = '' ) THEN\r\n  SET `TITLE` = '&nbsp;';\r\nEND IF;\r\n\r\nIF( (`REPORT_ID` IS NULL || `REPORT_ID` = 0)\r\n  AND `VARS_JSON` IS NULL ) THEN\r\n  RETURN CONCAT(\r\n    '<label class=\"toggle-trigger active\">'\r\n    , \/*'<a href=\"#\" debug=1>',*\/ TITLE\/*, '<\/a>'*\/\r\n    , '<\/label>');\r\nEND IF;\r\n\r\nSET @DATA = JSON_OBJECT( 'sql_variables', CAST( `VARS_JSON` AS JSON ) );\r\nSET @DATA = JSON_OBJECT( \r\n    'action', 'agendapartage_report_action',\r\n    'method', 'report_html',\r\n    'data[parent_post]', @POSTID,\r\n    'data[report_id]', `REPORT_ID`,\r\n    'data[sql_variables]', `VARS_JSON`\r\n);\r\nSET @DATA = REPLACE( @DATA, '\"', '&quot;');\r\n\r\nRETURN CONCAT(\r\n    '<label class=\"toggle-trigger\" ajax=1'\r\n    \t, ' data=\"', @DATA, '\">'\r\n        , \/*'<a href=\"#\" debug=2>',*\/ TITLE\/*, '<\/a>'*\/\r\n    , '<\/label>');","use_example":"TOGGLER(\r\n'\/tutoriels\/taxonomies\/taxonomie-termes'\r\n, 'sql_function'\r\n, JSON_OBJECT('taxonomy', 'sql_function')\r\n)"}}],"taxonomies":{"sql_function":"sql_function","report_style":"report_style"}}